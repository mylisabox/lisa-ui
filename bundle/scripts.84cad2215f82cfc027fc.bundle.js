webpackJsonp([1, 4], {
  2: function (n, e, t) {
    n.exports = t("27n8")
  }, "27n8": function (n, e, t) {
    t("P+fo")(t("pQSb"))
  }, "P+fo": function (n, e) {
    n.exports = function (n) {
      "undefined" != typeof execScript ? execScript(n) : eval.call(null, n)
    }
  }, pQSb: function (n, e) {
    n.exports = "(function UMDish(name, context, definition, plugins) {\n  context[name] = definition.call(context);\n  for (var i = 0; i < plugins.length; i++) {\n    plugins[i](context[name])\n  }\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = context[name];\n  } else if (typeof define === \"function\" && define.amd) {\n    define(function reference() {\n      return context[name];\n    });\n  }\n})(\"Primus\", this || {}, function wrapper() {\n    var define, module, exports\n      , Primus = (function e(t, n, r) {\n      function s(o, u) {\n        if (!n[o]) {\n          if (!t[o]) {\n            var a = typeof require == \"function\" && require;\n            if (!u && a)return a(o, !0);\n            if (i)return i(o, !0);\n            var f = new Error(\"Cannot find module '\" + o + \"'\");\n            throw f.code = \"MODULE_NOT_FOUND\", f\n          }\n          var l = n[o] = {exports: {}};\n          t[o][0].call(l.exports, function (e) {\n            var n = t[o][1][e];\n            return s(n ? n : e)\n          }, l, l.exports, e, t, n, r)\n        }\n        return n[o].exports\n      }\n\n      var i = typeof require == \"function\" && require;\n      for (var o = 0; o < r.length; o++)s(r[o]);\n      return s\n    })({\n      1: [function (_dereq_, module, exports) {\n        'use strict';\n\n        /**\n         * Create a function that will cleanup the instance.\n         *\n         * @param {Array|String} keys Properties on the instance that needs to be cleared.\n         * @param {Object} options Additional configuration.\n         * @returns {Function} Destroy function\n         * @api public\n         */\n        module.exports = function demolish(keys, options) {\n          var split = /[, ]+/;\n\n          options = options || {};\n          keys = keys || [];\n\n          if ('string' === typeof keys) keys = keys.split(split);\n\n        /**\n         * Run addition cleanup hooks.\n         *\n         * @param {String} key Name of the clean up hook to run.\n         * @param {Mixed} selfie Reference to the instance we're cleaning up.\n         * @api private\n         */\n        function run(key, selfie) {\n          if (!options[key]) return;\n          if ('string' === typeof options[key]) options[key] = options[key].split(split);\n          if ('function' === typeof options[key]) return options[key].call(selfie);\n\n          for (var i = 0, type, what; i < options[key].length; i++) {\n            what = options[key][i];\n            type = typeof what;\n\n            if ('function' === type) {\n              what.call(selfie);\n            } else if ('string' === type && 'function' === typeof selfie[what]) {\n              selfie[what]();\n            }\n          }\n        }\n\n          /**\n           * Destroy the instance completely and clean up all the existing references.\n           *\n           * @returns {Boolean}\n           * @api public\n           */\n          return function destroy() {\n            var selfie = this\n              , i = 0\n              , prop;\n\n            if (selfie[keys[0]] === null) return false;\n            run('before', selfie);\n\n            for (; i < keys.length; i++) {\n              prop = keys[i];\n\n              if (selfie[prop]) {\n                if ('function' === typeof selfie[prop].destroy) selfie[prop].destroy();\n                selfie[prop] = null;\n            }\n          }\n\n            if (selfie.emit) selfie.emit('destroy');\n            run('after', selfie);\n\n            return true;\n          };\n        };\n\n      }, {}],\n      2: [function (_dereq_, module, exports) {\n        'use strict';\n\n        /**\n         * Returns a function that when invoked executes all the listeners of the\n         * given event with the given arguments.\n         *\n         * @returns {Function} The function that emits all the things.\n         * @api public\n         */\n        module.exports = function emits() {\n          var self = this\n            , parser;\n\n          for (var i = 0, l = arguments.length, args = new Array(l); i < l; i++) {\n            args[i] = arguments[i];\n          }\n\n          //\n          // If the last argument is a function, assume that it's a parser.\n          //\n          if ('function' !== typeof args[args.length - 1]) return function emitter() {\n            for (var i = 0, l = arguments.length, arg = new Array(l); i < l; i++) {\n              arg[i] = arguments[i];\n            }\n\n            return self.emit.apply(self, args.concat(arg));\n        };\n\n          parser = args.pop();\n\n        /**\n         * The actual function that emits the given event. It returns a boolean\n         * indicating if the event was emitted.\n         *\n         * @returns {Boolean}\n         * @api public\n         */\n          return function emitter() {\n            for (var i = 0, l = arguments.length, arg = new Array(l + 1); i < l; i++) {\n              arg[i + 1] = arguments[i];\n          }\n\n          /**\n           * Async completion method for the parser.\n           *\n           * @param {Error} err Optional error when parsing failed.\n           * @param {Mixed} returned Emit instructions.\n           * @api private\n           */\n          arg[0] = function next(err, returned) {\n            if (err) return self.emit('error', err);\n\n            arg = returned === undefined\n              ? arg.slice(1) : returned === null\n              ? [] : returned;\n\n            self.emit.apply(self, args.concat(arg));\n          };\n\n            parser.apply(self, arg);\n            return true;\n        };\n        };\n\n      }, {}],\n      3: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\n        var prefix = typeof Object.create !== 'function' ? '~' : false;\n\n        /**\n         * Representation of a single EventEmitter function.\n         *\n         * @param {Function} fn Event handler to be called.\n         * @param {Mixed} context Context for function execution.\n         * @param {Boolean} [once=false] Only emit once\n         * @api private\n         */\n        function EE(fn, context, once) {\n          this.fn = fn;\n          this.context = context;\n          this.once = once || false;\n        }\n\n        /**\n         * Minimal EventEmitter interface that is molded against the Node.js\n         * EventEmitter interface.\n         *\n         * @constructor\n         * @api public\n         */\n        function EventEmitter() { /* Nothing to set */\n        }\n\n        /**\n         * Hold the assigned EventEmitters by name.\n         *\n         * @type {Object}\n         * @private\n         */\n        EventEmitter.prototype._events = undefined;\n\n        /**\n         * Return an array listing the events for which the emitter has registered\n         * listeners.\n         *\n         * @returns {Array}\n         * @api public\n         */\n        EventEmitter.prototype.eventNames = function eventNames() {\n          var events = this._events\n            , names = []\n            , name;\n\n          if (!events) return names;\n\n          for (name in events) {\n            if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n          }\n\n          if (Object.getOwnPropertySymbols) {\n            return names.concat(Object.getOwnPropertySymbols(events));\n          }\n\n          return names;\n        };\n\n        /**\n         * Return a list of assigned event listeners.\n         *\n         * @param {String} event The events that should be listed.\n         * @param {Boolean} exists We only need to know if there are listeners.\n         * @returns {Array|Boolean}\n         * @api public\n         */\n        EventEmitter.prototype.listeners = function listeners(event, exists) {\n          var evt = prefix ? prefix + event : event\n            , available = this._events && this._events[evt];\n\n          if (exists) return !!available;\n          if (!available) return [];\n          if (available.fn) return [available.fn];\n\n          for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n            ee[i] = available[i].fn;\n          }\n\n          return ee;\n        };\n\n        /**\n         * Emit an event to all registered event listeners.\n         *\n         * @param {String} event The name of the event.\n         * @returns {Boolean} Indication if we've emitted an event.\n         * @api public\n         */\n        EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n          var evt = prefix ? prefix + event : event;\n\n          if (!this._events || !this._events[evt]) return false;\n\n          var listeners = this._events[evt]\n            , len = arguments.length\n            , args\n            , i;\n\n          if ('function' === typeof listeners.fn) {\n            if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n            switch (len) {\n              case 1:\n                return listeners.fn.call(listeners.context), true;\n              case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n              case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n              case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n              case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n              case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n            }\n\n            for (i = 1, args = new Array(len - 1); i < len; i++) {\n              args[i - 1] = arguments[i];\n            }\n\n            listeners.fn.apply(listeners.context, args);\n          } else {\n            var length = listeners.length\n              , j;\n\n            for (i = 0; i < length; i++) {\n              if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n              switch (len) {\n                case 1:\n                  listeners[i].fn.call(listeners[i].context);\n                  break;\n                case 2:\n                  listeners[i].fn.call(listeners[i].context, a1);\n                  break;\n                case 3:\n                  listeners[i].fn.call(listeners[i].context, a1, a2);\n                  break;\n                default:\n                  if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n                    args[j - 1] = arguments[j];\n                  }\n\n                  listeners[i].fn.apply(listeners[i].context, args);\n            }\n          }\n          }\n\n          return true;\n        };\n\n        /**\n         * Register a new EventListener for the given event.\n         *\n         * @param {String} event Name of the event.\n         * @param {Function} fn Callback function.\n         * @param {Mixed} [context=this] The context of the function.\n         * @api public\n         */\n        EventEmitter.prototype.on = function on(event, fn, context) {\n          var listener = new EE(fn, context || this)\n            , evt = prefix ? prefix + event : event;\n\n          if (!this._events) this._events = prefix ? {} : Object.create(null);\n          if (!this._events[evt]) this._events[evt] = listener;\n          else {\n            if (!this._events[evt].fn) this._events[evt].push(listener);\n            else this._events[evt] = [\n              this._events[evt], listener\n            ];\n          }\n\n          return this;\n        };\n\n        /**\n         * Add an EventListener that's only called once.\n         *\n         * @param {String} event Name of the event.\n         * @param {Function} fn Callback function.\n         * @param {Mixed} [context=this] The context of the function.\n         * @api public\n         */\n        EventEmitter.prototype.once = function once(event, fn, context) {\n          var listener = new EE(fn, context || this, true)\n            , evt = prefix ? prefix + event : event;\n\n          if (!this._events) this._events = prefix ? {} : Object.create(null);\n          if (!this._events[evt]) this._events[evt] = listener;\n          else {\n            if (!this._events[evt].fn) this._events[evt].push(listener);\n            else this._events[evt] = [\n              this._events[evt], listener\n            ];\n          }\n\n          return this;\n        };\n\n        /**\n         * Remove event listeners.\n         *\n         * @param {String} event The event we want to remove.\n         * @param {Function} fn The listener that we need to find.\n         * @param {Mixed} context Only remove listeners matching this context.\n         * @param {Boolean} once Only remove once listeners.\n         * @api public\n         */\n        EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n          var evt = prefix ? prefix + event : event;\n\n          if (!this._events || !this._events[evt]) return this;\n\n          var listeners = this._events[evt]\n            , events = [];\n\n          if (fn) {\n            if (listeners.fn) {\n              if (\n                listeners.fn !== fn\n                || (once && !listeners.once)\n                || (context && listeners.context !== context)\n              ) {\n                events.push(listeners);\n              }\n            } else {\n              for (var i = 0, length = listeners.length; i < length; i++) {\n              if (\n                listeners[i].fn !== fn\n                || (once && !listeners[i].once)\n                || (context && listeners[i].context !== context)\n              ) {\n                events.push(listeners[i]);\n              }\n            }\n          }\n          }\n\n          //\n          // Reset the array, or remove it completely if we have no more listeners.\n          //\n          if (events.length) {\n            this._events[evt] = events.length === 1 ? events[0] : events;\n          } else {\n            delete this._events[evt];\n          }\n\n          return this;\n        };\n\n        /**\n         * Remove all listeners or only the listeners for the specified event.\n         *\n         * @param {String} event The event want to remove all listeners for.\n         * @api public\n         */\n        EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n          if (!this._events) return this;\n\n          if (event) delete this._events[prefix ? prefix + event : event];\n          else this._events = prefix ? {} : Object.create(null);\n\n          return this;\n        };\n\n//\n// Alias methods names because people roll like that.\n//\n        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n        EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\n        EventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n          return this;\n        };\n\n//\n// Expose the prefix.\n//\n        EventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\n        if ('undefined' !== typeof module) {\n          module.exports = EventEmitter;\n        }\n\n      }, {}],\n      4: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var regex = new RegExp('^((?:\\\\d+)?\\\\.?\\\\d+) *(' + [\n            'milliseconds?',\n            'msecs?',\n            'ms',\n            'seconds?',\n            'secs?',\n            's',\n            'minutes?',\n            'mins?',\n            'm',\n            'hours?',\n            'hrs?',\n            'h',\n            'days?',\n            'd',\n            'weeks?',\n            'wks?',\n            'w',\n            'years?',\n            'yrs?',\n            'y'\n          ].join('|') + ')?$', 'i');\n\n        var second = 1000\n          , minute = second * 60\n          , hour = minute * 60\n          , day = hour * 24\n          , week = day * 7\n          , year = day * 365;\n\n        /**\n         * Parse a time string and return the number value of it.\n         *\n         * @param {String} ms Time string.\n         * @returns {Number}\n         * @api private\n         */\n        module.exports = function millisecond(ms) {\n          var type = typeof ms\n            , amount\n            , match;\n\n          if ('number' === type) return ms;\n          else if ('string' !== type || '0' === ms || !ms) return 0;\n          else if (+ms) return +ms;\n\n          //\n          // We are vulnerable to the regular expression denial of service (ReDoS).\n          // In order to mitigate this we don't parse the input string if it is too long.\n          // See https://nodesecurity.io/advisories/46.\n          //\n          if (ms.length > 10000 || !(match = regex.exec(ms))) return 0;\n\n          amount = parseFloat(match[1]);\n\n          switch (match[2].toLowerCase()) {\n            case 'years':\n            case 'year':\n            case 'yrs':\n            case 'yr':\n            case 'y':\n              return amount * year;\n\n            case 'weeks':\n            case 'week':\n            case 'wks':\n            case 'wk':\n            case 'w':\n              return amount * week;\n\n            case 'days':\n            case 'day':\n            case 'd':\n              return amount * day;\n\n            case 'hours':\n            case 'hour':\n            case 'hrs':\n            case 'hr':\n            case 'h':\n              return amount * hour;\n\n            case 'minutes':\n            case 'minute':\n            case 'mins':\n            case 'min':\n            case 'm':\n              return amount * minute;\n\n            case 'seconds':\n            case 'second':\n            case 'secs':\n            case 'sec':\n            case 's':\n              return amount * second;\n\n            default:\n              return amount;\n          }\n        };\n\n      }, {}],\n      5: [function (_dereq_, module, exports) {\n        'use strict';\n\n        /**\n         * Wrap callbacks to prevent double execution.\n         *\n         * @param {Function} fn Function that should only be called once.\n         * @returns {Function} A wrapped callback which prevents execution.\n         * @api public\n         */\n        module.exports = function one(fn) {\n          var called = 0\n            , value;\n\n        /**\n         * The function that prevents double execution.\n         *\n         * @api private\n         */\n        function onetime() {\n          if (called) return value;\n\n          called = 1;\n          value = fn.apply(this, arguments);\n          fn = null;\n\n          return value;\n        }\n\n          //\n          // To make debugging more easy we want to use the name of the supplied\n          // function. So when you look at the functions that are assigned to event\n          // listeners you don't see a load of `onetime` functions but actually the\n          // names of the functions that this module will call.\n          //\n          onetime.displayName = fn.displayName || fn.name || onetime.displayName || onetime.name;\n          return onetime;\n        };\n\n      }, {}],\n      6: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var has = Object.prototype.hasOwnProperty;\n\n        /**\n         * Simple query string parser.\n         *\n         * @param {String} query The query string that needs to be parsed.\n         * @returns {Object}\n         * @api public\n         */\n        function querystring(query) {\n          var parser = /([^=?&]+)=([^&]*)/g\n            , result = {}\n            , part;\n\n          //\n          // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n          // the lastIndex property so we can continue executing this loop until we've\n          // parsed all results.\n          //\n          for (;\n            part = parser.exec(query);\n            result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n          );\n\n          return result;\n        }\n\n        /**\n         * Transform a query string to an object.\n         *\n         * @param {Object} obj Object that should be transformed.\n         * @param {String} prefix Optional prefix.\n         * @returns {String}\n         * @api public\n         */\n        function querystringify(obj, prefix) {\n          prefix = prefix || '';\n\n          var pairs = [];\n\n          //\n          // Optionally prefix with a '?' if needed\n          //\n          if ('string' !== typeof prefix) prefix = '?';\n\n          for (var key in obj) {\n            if (has.call(obj, key)) {\n              pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\n          }\n        }\n\n          return pairs.length ? prefix + pairs.join('&') : '';\n        }\n\n//\n// Expose the module.\n//\n        exports.stringify = querystringify;\n        exports.parse = querystring;\n\n      }, {}],\n      7: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var EventEmitter = _dereq_('eventemitter3')\n          , millisecond = _dereq_('millisecond')\n          , destroy = _dereq_('demolish')\n          , Tick = _dereq_('tick-tock')\n          , one = _dereq_('one-time');\n\n        /**\n         * Returns sane defaults about a given value.\n         *\n         * @param {String} name Name of property we want.\n         * @param {Recovery} selfie Recovery instance that got created.\n         * @param {Object} opts User supplied options we want to check.\n         * @returns {Number} Some default value.\n         * @api private\n         */\n        function defaults(name, selfie, opts) {\n          return millisecond(\n            name in opts ? opts[name] : (name in selfie ? selfie[name] : Recovery[name])\n          );\n        }\n\n        /**\n         * Attempt to recover your connection with reconnection attempt.\n         *\n         * @constructor\n         * @param {Object} options Configuration\n         * @api public\n         */\n        function Recovery(options) {\n          var recovery = this;\n\n          if (!(recovery instanceof Recovery)) return new Recovery(options);\n\n          options = options || {};\n\n          recovery.attempt = null;        // Stores the current reconnect attempt.\n          recovery._fn = null;            // Stores the callback.\n\n          recovery['reconnect timeout'] = defaults('reconnect timeout', recovery, options);\n          recovery.retries = defaults('retries', recovery, options);\n          recovery.factor = defaults('factor', recovery, options);\n          recovery.max = defaults('max', recovery, options);\n          recovery.min = defaults('min', recovery, options);\n          recovery.timers = new Tick(recovery);\n        }\n\n        Recovery.prototype = new EventEmitter();\n        Recovery.prototype.constructor = Recovery;\n\n        Recovery['reconnect timeout'] = '30 seconds';  // Maximum time to wait for an answer.\n        Recovery.max = Infinity;                       // Maximum delay.\n        Recovery.min = '500 ms';                       // Minimum delay.\n        Recovery.retries = 10;                         // Maximum amount of retries.\n        Recovery.factor = 2;                           // Exponential back off factor.\n\n        /**\n         * Start a new reconnect procedure.\n         *\n         * @returns {Recovery}\n         * @api public\n         */\n        Recovery.prototype.reconnect = function reconnect() {\n          var recovery = this;\n\n          return recovery.backoff(function backedoff(err, opts) {\n            opts.duration = (+new Date()) - opts.start;\n\n            if (err) return recovery.emit('reconnect failed', err, opts);\n\n            recovery.emit('reconnected', opts);\n          }, recovery.attempt);\n        };\n\n        /**\n         * Exponential back off algorithm for retry operations. It uses a randomized\n         * retry so we don't DDOS our server when it goes down under pressure.\n         *\n         * @param {Function} fn Callback to be called after the timeout.\n         * @param {Object} opts Options for configuring the timeout.\n         * @returns {Recovery}\n         * @api private\n         */\n        Recovery.prototype.backoff = function backoff(fn, opts) {\n          var recovery = this;\n\n          opts = opts || recovery.attempt || {};\n\n          //\n          // Bailout when we already have a back off process running. We shouldn't call\n          // the callback then.\n          //\n          if (opts.backoff) return recovery;\n\n          opts['reconnect timeout'] = defaults('reconnect timeout', recovery, opts);\n          opts.retries = defaults('retries', recovery, opts);\n          opts.factor = defaults('factor', recovery, opts);\n          opts.max = defaults('max', recovery, opts);\n          opts.min = defaults('min', recovery, opts);\n\n          opts.start = +opts.start || +new Date();\n          opts.duration = +opts.duration || 0;\n          opts.attempt = +opts.attempt || 0;\n\n          //\n          // Bailout if we are about to make too much attempts.\n          //\n          if (opts.attempt === opts.retries) {\n            fn.call(recovery, new Error('Unable to recover'), opts);\n            return recovery;\n          }\n\n          //\n          // Prevent duplicate back off attempts using the same options object and\n          // increment our attempt as we're about to have another go at this thing.\n          //\n          opts.backoff = true;\n          opts.attempt++;\n\n          recovery.attempt = opts;\n\n          //\n          // Calculate the timeout, but make it randomly so we don't retry connections\n          // at the same interval and defeat the purpose. This exponential back off is\n          // based on the work of:\n          //\n          // http://dthain.blogspot.nl/2009/02/exponential-backoff-in-distributed.html\n          //\n          opts.scheduled = opts.attempt !== 1\n            ? Math.min(Math.round(\n            (Math.random() + 1) * opts.min * Math.pow(opts.factor, opts.attempt - 1)\n          ), opts.max)\n            : opts.min;\n\n          recovery.timers.setTimeout('reconnect', function delay() {\n            opts.duration = (+new Date()) - opts.start;\n            opts.backoff = false;\n            recovery.timers.clear('reconnect, timeout');\n\n          //\n            // Create a `one` function which can only be called once. So we can use the\n            // same function for different types of invocations to create a much better\n            // and usable API.\n          //\n            var connect = recovery._fn = one(function connect(err) {\n              recovery.reset();\n\n              if (err) return recovery.backoff(fn, opts);\n\n              fn.call(recovery, undefined, opts);\n            });\n\n            recovery.emit('reconnect', opts, connect);\n            recovery.timers.setTimeout('timeout', function timeout() {\n              var err = new Error('Failed to reconnect in a timely manner');\n              opts.duration = (+new Date()) - opts.start;\n\n              recovery.emit('reconnect timeout', err, opts);\n              connect(err);\n            }, opts['reconnect timeout']);\n          }, opts.scheduled);\n\n          //\n          // Emit a `reconnecting` event with current reconnect options. This allows\n          // them to update the UI and provide their users with feedback.\n          //\n          recovery.emit('reconnect scheduled', opts);\n\n          return recovery;\n        };\n\n        /**\n         * Check if the reconnection process is currently reconnecting.\n         *\n         * @returns {Boolean}\n         * @api public\n         */\n        Recovery.prototype.reconnecting = function reconnecting() {\n          return !!this.attempt;\n        };\n\n        /**\n         * Tell our reconnection procedure that we're passed.\n         *\n         * @param {Error} err Reconnection failed.\n         * @returns {Recovery}\n         * @api public\n         */\n        Recovery.prototype.reconnected = function reconnected(err) {\n          if (this._fn) this._fn(err);\n          return this;\n        };\n\n        /**\n         * Reset the reconnection attempt so it can be re-used again.\n         *\n         * @returns {Recovery}\n         * @api public\n         */\n        Recovery.prototype.reset = function reset() {\n          this._fn = this.attempt = null;\n          this.timers.clear('reconnect, timeout');\n\n          return this;\n        };\n\n        /**\n         * Clean up the instance.\n         *\n         * @type {Function}\n         * @returns {Boolean}\n         * @api public\n         */\n        Recovery.prototype.destroy = destroy('timers attempt _fn');\n\n//\n// Expose the module.\n//\n        module.exports = Recovery;\n\n      }, {\"demolish\": 1, \"eventemitter3\": 8, \"millisecond\": 4, \"one-time\": 5, \"tick-tock\": 10}],\n      8: [function (_dereq_, module, exports) {\n        'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\n        var prefix = typeof Object.create !== 'function' ? '~' : false;\n\n        /**\n         * Representation of a single EventEmitter function.\n         *\n         * @param {Function} fn Event handler to be called.\n         * @param {Mixed} context Context for function execution.\n         * @param {Boolean} once Only emit once\n         * @api private\n         */\n        function EE(fn, context, once) {\n          this.fn = fn;\n          this.context = context;\n          this.once = once || false;\n        }\n\n        /**\n         * Minimal EventEmitter interface that is molded against the Node.js\n         * EventEmitter interface.\n         *\n         * @constructor\n         * @api public\n         */\n        function EventEmitter() { /* Nothing to set */\n        }\n\n        /**\n         * Holds the assigned EventEmitters by name.\n         *\n         * @type {Object}\n         * @private\n         */\n        EventEmitter.prototype._events = undefined;\n\n        /**\n         * Return a list of assigned event listeners.\n         *\n         * @param {String} event The events that should be listed.\n         * @param {Boolean} exists We only need to know if there are listeners.\n         * @returns {Array|Boolean}\n         * @api public\n         */\n        EventEmitter.prototype.listeners = function listeners(event, exists) {\n          var evt = prefix ? prefix + event : event\n            , available = this._events && this._events[evt];\n\n          if (exists) return !!available;\n          if (!available) return [];\n          if (available.fn) return [available.fn];\n\n          for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n            ee[i] = available[i].fn;\n          }\n\n          return ee;\n        };\n\n        /**\n         * Emit an event to all registered event listeners.\n         *\n         * @param {String} event The name of the event.\n         * @returns {Boolean} Indication if we've emitted an event.\n         * @api public\n         */\n        EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n          var evt = prefix ? prefix + event : event;\n\n          if (!this._events || !this._events[evt]) return false;\n\n          var listeners = this._events[evt]\n            , len = arguments.length\n            , args\n            , i;\n\n          if ('function' === typeof listeners.fn) {\n            if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n            switch (len) {\n              case 1:\n                return listeners.fn.call(listeners.context), true;\n              case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n              case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n              case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n              case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n              case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n            }\n\n            for (i = 1, args = new Array(len - 1); i < len; i++) {\n              args[i - 1] = arguments[i];\n            }\n\n            listeners.fn.apply(listeners.context, args);\n          } else {\n            var length = listeners.length\n              , j;\n\n            for (i = 0; i < length; i++) {\n              if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n              switch (len) {\n                case 1:\n                  listeners[i].fn.call(listeners[i].context);\n                  break;\n                case 2:\n                  listeners[i].fn.call(listeners[i].context, a1);\n                  break;\n                case 3:\n                  listeners[i].fn.call(listeners[i].context, a1, a2);\n                  break;\n                default:\n                  if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n                    args[j - 1] = arguments[j];\n                  }\n\n                  listeners[i].fn.apply(listeners[i].context, args);\n            }\n          }\n          }\n\n          return true;\n        };\n\n        /**\n         * Register a new EventListener for the given event.\n         *\n         * @param {String} event Name of the event.\n         * @param {Functon} fn Callback function.\n         * @param {Mixed} context The context of the function.\n         * @api public\n         */\n        EventEmitter.prototype.on = function on(event, fn, context) {\n          var listener = new EE(fn, context || this)\n            , evt = prefix ? prefix + event : event;\n\n          if (!this._events) this._events = prefix ? {} : Object.create(null);\n          if (!this._events[evt]) this._events[evt] = listener;\n          else {\n            if (!this._events[evt].fn) this._events[evt].push(listener);\n            else this._events[evt] = [\n              this._events[evt], listener\n            ];\n          }\n\n          return this;\n        };\n\n        /**\n         * Add an EventListener that's only called once.\n         *\n         * @param {String} event Name of the event.\n         * @param {Function} fn Callback function.\n         * @param {Mixed} context The context of the function.\n         * @api public\n         */\n        EventEmitter.prototype.once = function once(event, fn, context) {\n          var listener = new EE(fn, context || this, true)\n            , evt = prefix ? prefix + event : event;\n\n          if (!this._events) this._events = prefix ? {} : Object.create(null);\n          if (!this._events[evt]) this._events[evt] = listener;\n          else {\n            if (!this._events[evt].fn) this._events[evt].push(listener);\n            else this._events[evt] = [\n              this._events[evt], listener\n            ];\n          }\n\n          return this;\n        };\n\n        /**\n         * Remove event listeners.\n         *\n         * @param {String} event The event we want to remove.\n         * @param {Function} fn The listener that we need to find.\n         * @param {Mixed} context Only remove listeners matching this context.\n         * @param {Boolean} once Only remove once listeners.\n         * @api public\n         */\n        EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n          var evt = prefix ? prefix + event : event;\n\n          if (!this._events || !this._events[evt]) return this;\n\n          var listeners = this._events[evt]\n            , events = [];\n\n          if (fn) {\n            if (listeners.fn) {\n              if (\n                listeners.fn !== fn\n                || (once && !listeners.once)\n                || (context && listeners.context !== context)\n              ) {\n                events.push(listeners);\n              }\n            } else {\n              for (var i = 0, length = listeners.length; i < length; i++) {\n              if (\n                listeners[i].fn !== fn\n                || (once && !listeners[i].once)\n                || (context && listeners[i].context !== context)\n              ) {\n                events.push(listeners[i]);\n              }\n            }\n          }\n          }\n\n          //\n          // Reset the array, or remove it completely if we have no more listeners.\n          //\n          if (events.length) {\n            this._events[evt] = events.length === 1 ? events[0] : events;\n          } else {\n            delete this._events[evt];\n          }\n\n          return this;\n        };\n\n        /**\n         * Remove all listeners or only the listeners for the specified event.\n         *\n         * @param {String} event The event want to remove all listeners for.\n         * @api public\n         */\n        EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n          if (!this._events) return this;\n\n          if (event) delete this._events[prefix ? prefix + event : event];\n          else this._events = prefix ? {} : Object.create(null);\n\n          return this;\n        };\n\n//\n// Alias methods names because people roll like that.\n//\n        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n        EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\n        EventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n          return this;\n        };\n\n//\n// Expose the prefix.\n//\n        EventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\n        if ('undefined' !== typeof module) {\n          module.exports = EventEmitter;\n        }\n\n      }, {}],\n      9: [function (_dereq_, module, exports) {\n        'use strict';\n\n        /**\n         * Check if we're required to add a port number.\n         *\n         * @see https://url.spec.whatwg.org/#default-port\n         * @param {Number|String} port Port number we need to check\n         * @param {String} protocol Protocol we need to check against.\n         * @returns {Boolean} Is it a default port for the given protocol\n         * @api private\n         */\n        module.exports = function required(port, protocol) {\n          protocol = protocol.split(':')[0];\n          port = +port;\n\n          if (!port) return false;\n\n          switch (protocol) {\n            case 'http':\n            case 'ws':\n              return port !== 80;\n\n            case 'https':\n            case 'wss':\n              return port !== 443;\n\n            case 'ftp':\n              return port !== 21;\n\n            case 'gopher':\n              return port !== 70;\n\n            case 'file':\n              return false;\n        }\n\n          return port !== 0;\n        };\n\n      }, {}],\n      10: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var has = Object.prototype.hasOwnProperty\n          , ms = _dereq_('millisecond');\n\n        /**\n         * Timer instance.\n         *\n         * @constructor\n         * @param {Object} timer New timer instance.\n         * @param {Function} clear Clears the timer instance.\n         * @param {Function} duration Duration of the timer.\n         * @param {Function} fn The functions that need to be executed.\n         * @api private\n         */\n        function Timer(timer, clear, duration, fn) {\n          this.start = +(new Date());\n          this.duration = duration;\n          this.clear = clear;\n          this.timer = timer;\n          this.fns = [fn];\n        }\n\n        /**\n         * Calculate the time left for a given timer.\n         *\n         * @returns {Number} Time in milliseconds.\n         * @api public\n         */\n        Timer.prototype.remaining = function remaining() {\n          return this.duration - this.taken();\n        };\n\n        /**\n         * Calculate the amount of time it has taken since we've set the timer.\n         *\n         * @returns {Number}\n         * @api public\n         */\n        Timer.prototype.taken = function taken() {\n          return +(new Date()) - this.start;\n        };\n\n        /**\n         * Custom wrappers for the various of clear{whatever} functions. We cannot\n         * invoke them directly as this will cause thrown errors in Google Chrome with\n         * an Illegal Invocation Error\n         *\n         * @see #2\n         * @type {Function}\n         * @api private\n         */\n        function unsetTimeout(id) {\n          clearTimeout(id);\n        }\n\n        function unsetInterval(id) {\n          clearInterval(id);\n        }\n\n        function unsetImmediate(id) {\n          clearImmediate(id);\n        }\n\n        /**\n         * Simple timer management.\n         *\n         * @constructor\n         * @param {Mixed} context Context of the callbacks that we execute.\n         * @api public\n         */\n        function Tick(context) {\n          if (!(this instanceof Tick)) return new Tick(context);\n\n          this.timers = {};\n          this.context = context || this;\n        }\n\n        /**\n         * Return a function which will just iterate over all assigned callbacks and\n         * optionally clear the timers from memory if needed.\n         *\n         * @param {String} name Name of the timer we need to execute.\n         * @param {Boolean} clear Also clear from memory.\n         * @returns {Function}\n         * @api private\n         */\n        Tick.prototype.tock = function ticktock(name, clear) {\n          var tock = this;\n\n          return function tickedtock() {\n            if (!(name in tock.timers)) return;\n\n            var timer = tock.timers[name]\n              , fns = timer.fns.slice()\n              , l = fns.length\n              , i = 0;\n\n            if (clear) tock.clear(name);\n            else tock.start = +new Date();\n\n            for (; i < l; i++) {\n              fns[i].call(tock.context);\n          }\n          };\n        };\n\n        /**\n         * Add a new timeout.\n         *\n         * @param {String} name Name of the timer.\n         * @param {Function} fn Completion callback.\n         * @param {Mixed} time Duration of the timer.\n         * @returns {Tick}\n         * @api public\n         */\n        Tick.prototype.setTimeout = function timeout(name, fn, time) {\n          var tick = this\n            , tock;\n\n          if (tick.timers[name]) {\n            tick.timers[name].fns.push(fn);\n          return tick;\n          }\n\n          tock = ms(time);\n          tick.timers[name] = new Timer(\n            setTimeout(tick.tock(name, true), ms(time)),\n            unsetTimeout,\n            tock,\n            fn\n          );\n\n          return tick;\n        };\n\n        /**\n         * Add a new interval.\n         *\n         * @param {String} name Name of the timer.\n         * @param {Function} fn Completion callback.\n         * @param {Mixed} time Interval of the timer.\n         * @returns {Tick}\n         * @api public\n         */\n        Tick.prototype.setInterval = function interval(name, fn, time) {\n          var tick = this\n            , tock;\n\n          if (tick.timers[name]) {\n            tick.timers[name].fns.push(fn);\n          return tick;\n          }\n\n          tock = ms(time);\n          tick.timers[name] = new Timer(\n            setInterval(tick.tock(name), ms(time)),\n            unsetInterval,\n            tock,\n            fn\n          );\n\n          return tick;\n        };\n\n        /**\n         * Add a new setImmediate.\n         *\n         * @param {String} name Name of the timer.\n         * @param {Function} fn Completion callback.\n         * @returns {Tick}\n         * @api public\n         */\n        Tick.prototype.setImmediate = function immediate(name, fn) {\n          var tick = this;\n\n          if ('function' !== typeof setImmediate) return tick.setTimeout(name, fn, 0);\n\n          if (tick.timers[name]) {\n            tick.timers[name].fns.push(fn);\n          return tick;\n          }\n\n          tick.timers[name] = new Timer(\n            setImmediate(tick.tock(name, true)),\n            unsetImmediate,\n            0,\n            fn\n          );\n\n          return tick;\n        };\n\n        /**\n         * Check if we have a timer set.\n         *\n         * @param {String} name\n         * @returns {Boolean}\n         * @api public\n         */\n        Tick.prototype.active = function active(name) {\n          return name in this.timers;\n        };\n\n        /**\n         * Properly clean up all timeout references. If no arguments are supplied we\n         * will attempt to clear every single timer that is present.\n         *\n         * @param {Arguments} ..args.. The names of the timeouts we need to clear\n         * @returns {Tick}\n         * @api public\n         */\n        Tick.prototype.clear = function clear() {\n          var args = arguments.length ? arguments : []\n            , tick = this\n            , timer, i, l;\n\n          if (args.length === 1 && 'string' === typeof args[0]) {\n            args = args[0].split(/[, ]+/);\n          }\n\n          if (!args.length) {\n            for (timer in tick.timers) {\n              if (has.call(tick.timers, timer)) args.push(timer);\n          }\n          }\n\n          for (i = 0, l = args.length; i < l; i++) {\n            timer = tick.timers[args[i]];\n\n            if (!timer) continue;\n            timer.clear(timer.timer);\n\n            timer.fns = timer.timer = timer.clear = null;\n            delete tick.timers[args[i]];\n          }\n\n          return tick;\n        };\n\n        /**\n         * Adjust a timeout or interval to a new duration.\n         *\n         * @returns {Tick}\n         * @api public\n         */\n        Tick.prototype.adjust = function adjust(name, time) {\n          var interval\n            , tick = this\n            , tock = ms(time)\n            , timer = tick.timers[name];\n\n          if (!timer) return tick;\n\n          interval = timer.clear === unsetInterval;\n          timer.clear(timer.timer);\n          timer.start = +(new Date());\n          timer.duration = tock;\n          timer.timer = (interval ? setInterval : setTimeout)(tick.tock(name, !interval), tock);\n\n          return tick;\n        };\n\n        /**\n         * We will no longer use this module, prepare your self for global cleanups.\n         *\n         * @returns {Boolean}\n         * @api public\n         */\n        Tick.prototype.end = Tick.prototype.destroy = function end() {\n          if (!this.context) return false;\n\n          this.clear();\n          this.context = this.timers = null;\n\n          return true;\n        };\n\n//\n// Expose the timer factory.\n//\n        Tick.Timer = Timer;\n        module.exports = Tick;\n\n      }, {\"millisecond\": 4}],\n      11: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var required = _dereq_('requires-port')\n          , lolcation = _dereq_('./lolcation')\n          , qs = _dereq_('querystringify')\n          , relativere = /^\\/(?!\\/)/\n          , protocolre = /^([a-z0-9.+-]+:)?(\\/\\/)?(.*)$/i; // actual protocol is first match\n\n        /**\n         * These are the parse instructions for the URL parsers, it informs the parser\n         * about:\n         *\n         * 0. The char it Needs to parse, if it's a string it should be done using\n         *    indexOf, RegExp using exec and NaN means set as current value.\n         * 1. The property we should set when parsing this value.\n         * 2. Indication if it's backwards or forward parsing, when set as number it's\n         *    the value of extra chars that should be split off.\n         * 3. Inherit from location if non existing in the parser.\n         * 4. `toLowerCase` the resulting value.\n         */\n        var instructions = [\n          ['#', 'hash'],                        // Extract from the back.\n          ['?', 'query'],                       // Extract from the back.\n          ['/', 'pathname'],                    // Extract from the back.\n          ['@', 'auth', 1],                     // Extract from the front.\n          [NaN, 'host', undefined, 1, 1],       // Set left over value.\n          [/\\:(\\d+)$/, 'port'],                 // RegExp the back.\n          [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n        ];\n\n        /**\n         * @typedef ProtocolExtract\n         * @type Object\n         * @property {String} protocol Protocol matched in the URL, in lowercase\n         * @property {Boolean} slashes Indicates whether the protocol is followed by double slash (\"//\")\n         * @property {String} rest     Rest of the URL that is not part of the protocol\n         */\n\n        /**\n         * Extract protocol information from a URL with/without double slash (\"//\")\n         *\n         * @param  {String} address   URL we want to extract from.\n         * @return {ProtocolExtract}  Extracted information\n         * @private\n         */\n        function extractProtocol(address) {\n          var match = protocolre.exec(address);\n          return {\n            protocol: match[1] ? match[1].toLowerCase() : '',\n            slashes: !!match[2],\n            rest: match[3] ? match[3] : ''\n          };\n        }\n\n        /**\n         * The actual URL instance. Instead of returning an object we've opted-in to\n         * create an actual constructor as it's much more memory efficient and\n         * faster and it pleases my CDO.\n         *\n         * @constructor\n         * @param {String} address URL we want to parse.\n         * @param {Object|String} location Location defaults for relative paths.\n         * @param {Boolean|Function} parser Parser for the query string.\n         * @api public\n         */\n        function URL(address, location, parser) {\n          if (!(this instanceof URL)) {\n            return new URL(address, location, parser);\n        }\n\n          var relative = relativere.test(address)\n            , parse, instruction, index, key\n            , type = typeof location\n            , url = this\n            , i = 0;\n\n          //\n          // The following if statements allows this module two have compatibility with\n          // 2 different API:\n          //\n          // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n          //    where the boolean indicates that the query string should also be parsed.\n          //\n          // 2. The `URL` interface of the browser which accepts a URL, object as\n          //    arguments. The supplied object will be used as default values / fall-back\n          //    for relative paths.\n          //\n          if ('object' !== type && 'string' !== type) {\n            parser = location;\n            location = null;\n          }\n\n          if (parser && 'function' !== typeof parser) {\n            parser = qs.parse;\n          }\n\n          location = lolcation(location);\n\n          // extract protocol information before running the instructions\n          var extracted = extractProtocol(address);\n          url.protocol = extracted.protocol || location.protocol || '';\n          url.slashes = extracted.slashes || location.slashes;\n          address = extracted.rest;\n\n          for (; i < instructions.length; i++) {\n            instruction = instructions[i];\n            parse = instruction[0];\n            key = instruction[1];\n\n            if (parse !== parse) {\n              url[key] = address;\n            } else if ('string' === typeof parse) {\n              if (~(index = address.indexOf(parse))) {\n                if ('number' === typeof instruction[2]) {\n                  url[key] = address.slice(0, index);\n                  address = address.slice(index + instruction[2]);\n                } else {\n                  url[key] = address.slice(index);\n                  address = address.slice(0, index);\n              }\n            }\n            } else if (index = parse.exec(address)) {\n              url[key] = index[1];\n              address = address.slice(0, address.length - index[0].length);\n          }\n\n            url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');\n\n          //\n            // Hostname, host and protocol should be lowercased so they can be used to\n            // create a proper `origin`.\n          //\n            if (instruction[4]) {\n              url[key] = url[key].toLowerCase();\n          }\n          }\n\n          //\n          // Also parse the supplied query string in to an object. If we're supplied\n          // with a custom parser as function use that instead of the default build-in\n          // parser.\n          //\n          if (parser) url.query = parser(url.query);\n\n          //\n          // We should not add port numbers if they are already the default port number\n          // for a given protocol. As the host also contains the port number we're going\n          // override it with the hostname which contains no port number.\n          //\n          if (!required(url.port, url.protocol)) {\n            url.host = url.hostname;\n            url.port = '';\n        }\n\n          //\n          // Parse down the `auth` for the username and password.\n          //\n          url.username = url.password = '';\n          if (url.auth) {\n            instruction = url.auth.split(':');\n            url.username = instruction[0] || '';\n            url.password = instruction[1] || '';\n          }\n\n          //\n          // The href is just the compiled result.\n          //\n          url.href = url.toString();\n        }\n\n        /**\n         * This is convenience method for changing properties in the URL instance to\n         * insure that they all propagate correctly.\n         *\n         * @param {String} prop          Property we need to adjust.\n         * @param {Mixed} value          The newly assigned value.\n         * @param {Boolean|Function} fn  When setting the query, it will be the function used to parse\n         *                               the query.\n         *                               When setting the protocol, double slash will be removed from\n         *                               the final url if it is true.\n         * @returns {URL}\n         * @api public\n         */\n        URL.prototype.set = function set(part, value, fn) {\n          var url = this;\n\n          if ('query' === part) {\n            if ('string' === typeof value && value.length) {\n              value = (fn || qs.parse)(value);\n            }\n\n            url[part] = value;\n          } else if ('port' === part) {\n            url[part] = value;\n\n            if (!required(value, url.protocol)) {\n              url.host = url.hostname;\n              url[part] = '';\n            } else if (value) {\n              url.host = url.hostname + ':' + value;\n          }\n          } else if ('hostname' === part) {\n            url[part] = value;\n\n            if (url.port) value += ':' + url.port;\n            url.host = value;\n          } else if ('host' === part) {\n            url[part] = value;\n\n            if (/\\:\\d+/.test(value)) {\n              value = value.split(':');\n              url.hostname = value[0];\n              url.port = value[1];\n            }\n          } else if ('protocol' === part) {\n            url.protocol = value;\n            url.slashes = !fn;\n          } else {\n            url[part] = value;\n          }\n\n          url.href = url.toString();\n          return url;\n        };\n\n        /**\n         * Transform the properties back in to a valid and full URL string.\n         *\n         * @param {Function} stringify Optional query stringify function.\n         * @returns {String}\n         * @api public\n         */\n        URL.prototype.toString = function toString(stringify) {\n          if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n          var query\n            , url = this\n            , protocol = url.protocol;\n\n          if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n          var result = protocol + (url.slashes ? '//' : '');\n\n          if (url.username) {\n            result += url.username;\n            if (url.password) result += ':' + url.password;\n            result += '@';\n          }\n\n          result += url.hostname;\n          if (url.port) result += ':' + url.port;\n\n          result += url.pathname;\n\n          query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n          if (query) result += '?' !== query.charAt(0) ? '?' + query : query;\n\n          if (url.hash) result += url.hash;\n\n          return result;\n        };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others.\n//\n        URL.qs = qs;\n        URL.location = lolcation;\n        module.exports = URL;\n\n      }, {\"./lolcation\": 12, \"querystringify\": 6, \"requires-port\": 9}],\n      12: [function (_dereq_, module, exports) {\n        (function (global) {\n          'use strict';\n\n          var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n\n          /**\n           * These properties should not be copied or inherited from. This is only needed\n           * for all non blob URL's as a blob URL does not include a hash, only the\n           * origin.\n           *\n           * @type {Object}\n           * @private\n           */\n          var ignore = {hash: 1, query: 1}\n            , URL;\n\n          /**\n           * The location object differs when your code is loaded through a normal page,\n           * Worker or through a worker using a blob. And with the blobble begins the\n           * trouble as the location object will contain the URL of the blob, not the\n           * location of the page where our code is loaded in. The actual origin is\n           * encoded in the `pathname` so we can thankfully generate a good \"default\"\n           * location from it so we can generate proper relative URL's again.\n           *\n           * @param {Object|String} loc Optional default location object.\n           * @returns {Object} lolcation object.\n           * @api public\n           */\n          module.exports = function lolcation(loc) {\n            loc = loc || global.location || {};\n            URL = URL || _dereq_('./');\n\n            var finaldestination = {}\n              , type = typeof loc\n              , key;\n\n            if ('blob:' === loc.protocol) {\n              finaldestination = new URL(unescape(loc.pathname), {});\n            } else if ('string' === type) {\n              finaldestination = new URL(loc, {});\n              for (key in ignore) delete finaldestination[key];\n            } else if ('object' === type) {\n              for (key in loc) {\n                if (key in ignore) continue;\n                finaldestination[key] = loc[key];\n              }\n\n              if (finaldestination.slashes === undefined) {\n                finaldestination.slashes = slashes.test(loc.href);\n            }\n            }\n\n            return finaldestination;\n          };\n\n        }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n      }, {\"./\": 11}],\n      13: [function (_dereq_, module, exports) {\n        'use strict';\n\n        var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n          , length = 64\n          , map = {}\n          , seed = 0\n          , i = 0\n          , prev;\n\n        /**\n         * Return a string representing the specified number.\n         *\n         * @param {Number} num The number to convert.\n         * @returns {String} The string representation of the number.\n         * @api public\n         */\n        function encode(num) {\n          var encoded = '';\n\n          do {\n            encoded = alphabet[num % length] + encoded;\n            num = Math.floor(num / length);\n          } while (num > 0);\n\n          return encoded;\n        }\n\n        /**\n         * Return the integer value specified by the given string.\n         *\n         * @param {String} str The string to convert.\n         * @returns {Number} The integer value represented by the string.\n         * @api public\n         */\n        function decode(str) {\n          var decoded = 0;\n\n          for (i = 0; i < str.length; i++) {\n            decoded = decoded * length + map[str.charAt(i)];\n        }\n\n          return decoded;\n        }\n\n        /**\n         * Yeast: A tiny growing id generator.\n         *\n         * @returns {String} A unique id.\n         * @api public\n         */\n        function yeast() {\n          var now = encode(+new Date());\n\n          if (now !== prev) return seed = 0, prev = now;\n          return now + '.' + encode(seed++);\n        }\n\n//\n// Map each character to its index.\n//\n        for (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\n        yeast.encode = encode;\n        yeast.decode = decode;\n        module.exports = yeast;\n\n      }, {}],\n      14: [function (_dereq_, module, exports) {\n        /*globals require, define */\n        'use strict';\n\n        var EventEmitter = _dereq_('eventemitter3')\n          , TickTock = _dereq_('tick-tock')\n          , Recovery = _dereq_('recovery')\n          , qs = _dereq_('querystringify')\n          , destroy = _dereq_('demolish')\n          , yeast = _dereq_('yeast')\n          , u2028 = /\\u2028/g\n          , u2029 = /\\u2029/g;\n\n        /**\n         * Context assertion, ensure that some of our public Primus methods are called\n         * with the correct context to ensure that\n         *\n         * @param {Primus} self The context of the function.\n         * @param {String} method The method name.\n         * @api private\n         */\n        function context(self, method) {\n          if (self instanceof Primus) return;\n\n          var failure = new Error('Primus#' + method + '\\'s context should called with a Primus instance');\n\n          if ('function' !== typeof self.listeners || !self.listeners('error').length) {\n            throw failure;\n        }\n\n          self.emit('error', failure);\n        }\n\n//\n// Sets the default connection URL, it uses the default origin of the browser\n// when supported but degrades for older browsers. In Node.js, we cannot guess\n// where the user wants to connect to, so we just default to localhost.\n//\n        var defaultUrl;\n\n        try {\n          if (location.origin) {\n            defaultUrl = location.origin;\n          } else {\n            defaultUrl = location.protocol + '//' + location.host;\n        }\n        } catch (e) {\n          defaultUrl = 'http://127.0.0.1';\n        }\n\n        /**\n         * Primus is a real-time library agnostic framework for establishing real-time\n         * connections with servers.\n         *\n         * Options:\n         * - reconnect, configuration for the reconnect process.\n         * - manual, don't automatically call `.open` to start the connection.\n         * - websockets, force the use of WebSockets, even when you should avoid them.\n         * - timeout, connect timeout, server didn't respond in a timely manner.\n         * - ping, The heartbeat interval for sending a ping packet to the server.\n         * - pong, The heartbeat timeout for receiving a response to the ping.\n         * - network, Use network events as leading method for network connection drops.\n         * - strategy, Reconnection strategies.\n         * - transport, Transport options.\n         * - url, uri, The URL to use connect with the server.\n         *\n         * @constructor\n         * @param {String} url The URL of your server.\n         * @param {Object} options The configuration.\n         * @api public\n         */\n        function Primus(url, options) {\n          if (!(this instanceof Primus)) return new Primus(url, options);\n          if ('function' !== typeof this.client) {\n            var message = 'The client library has not been compiled correctly, ' +\n              'see https://github.com/primus/primus#client-library for more details';\n            return this.critical(new Error(message));\n          }\n\n          if ('object' === typeof url) {\n            options = url;\n            url = options.url || options.uri || defaultUrl;\n          } else {\n            options = options || {};\n          }\n\n          var primus = this;\n          primus.join = function (room, fn) {\n            primus.send('join', room, fn)\n          };\n\n          primus.leave = function (room, fn) {\n            primus.send('leave', room, fn)\n          };\n          // The maximum number of messages that can be placed in queue.\n          options.queueSize = 'queueSize' in options ? options.queueSize : Infinity;\n\n          // Connection timeout duration.\n          options.timeout = 'timeout' in options ? options.timeout : 10e3;\n\n          // Stores the back off configuration.\n          options.reconnect = 'reconnect' in options ? options.reconnect : {};\n\n          // Heartbeat ping interval.\n          options.ping = 'ping' in options ? options.ping : 25000;\n\n          // Heartbeat pong response timeout.\n          options.pong = 'pong' in options ? options.pong : 10e3;\n\n          // Reconnect strategies.\n          options.strategy = 'strategy' in options ? options.strategy : [];\n\n          // Custom transport options.\n          options.transport = 'transport' in options ? options.transport : {};\n\n          primus.buffer = [];                           // Stores premature send data.\n          primus.writable = true;                       // Silly stream compatibility.\n          primus.readable = true;                       // Silly stream compatibility.\n          primus.url = primus.parse(url || defaultUrl); // Parse the URL to a readable format.\n          primus.readyState = Primus.CLOSED;            // The readyState of the connection.\n          primus.options = options;                     // Reference to the supplied options.\n          primus.timers = new TickTock(this);           // Contains all our timers.\n          primus.socket = null;                         // Reference to the internal connection.\n          primus.latency = 0;                           // Latency between messages.\n          primus.disconnect = false;                    // Did we receive a disconnect packet?\n          primus.transport = options.transport;         // Transport options.\n          primus.transformers = {                       // Message transformers.\n            outgoing: [],\n            incoming: []\n          };\n\n          //\n          // Create our reconnection instance.\n          //\n          primus.recovery = new Recovery(options.reconnect);\n\n          //\n          // Parse the reconnection strategy. It can have the following strategies:\n          //\n          // - timeout: Reconnect when we have a network timeout.\n          // - disconnect: Reconnect when we have an unexpected disconnect.\n          // - online: Reconnect when we're back online.\n          //\n          if ('string' === typeof options.strategy) {\n            options.strategy = options.strategy.split(/\\s?\\,\\s?/g);\n          }\n\n          if (false === options.strategy) {\n          //\n            // Strategies are disabled, but we still need an empty array to join it in\n            // to nothing.\n          //\n            options.strategy = [];\n          } else if (!options.strategy.length) {\n            options.strategy.push('disconnect', 'online');\n\n          //\n            // Timeout based reconnection should only be enabled conditionally. When\n            // authorization is enabled it could trigger.\n          //\n            if (!this.authorization) options.strategy.push('timeout');\n          }\n\n          options.strategy = options.strategy.join(',').toLowerCase();\n\n          //\n          // Force the use of WebSockets, even when we've detected some potential\n          // broken WebSocket implementation.\n          //\n          if ('websockets' in options) {\n            primus.AVOID_WEBSOCKETS = !options.websockets;\n          }\n\n          //\n          // Force or disable the use of NETWORK events as leading client side\n          // disconnection detection.\n          //\n          if ('network' in options) {\n            primus.NETWORK_EVENTS = options.network;\n          }\n\n          //\n          // Check if the user wants to manually initialise a connection. If they don't,\n          // we want to do it after a really small timeout so we give the users enough\n          // time to listen for `error` events etc.\n          //\n          if (!options.manual) primus.timers.setTimeout('open', function open() {\n            primus.timers.clear('open');\n            primus.open();\n          }, 0);\n\n          primus.initialise(options);\n        }\n\n        /**\n         * Simple require wrapper to make browserify, node and require.js play nice.\n         *\n         * @param {String} name The module to require.\n         * @returns {Object|Undefined} The module that we required.\n         * @api private\n         */\n        Primus.requires = Primus.require = function requires(name) {\n          if ('function' !== typeof _dereq_) return undefined;\n\n          return !('function' === typeof define && define.amd)\n            ? _dereq_(name)\n            : undefined;\n        };\n\n//\n// It's possible that we're running in Node.js or in a Node.js compatible\n// environment. In this cases we inherit from the Stream base class.\n//\n        var Stream;\n\n        try {\n          Primus.Stream = Stream = Primus.requires('stream');\n\n          //\n          // Normally inheritance is done in the same way as we do in our catch\n          // statement. But due to changes to the EventEmitter interface in Node 0.10\n          // this will trigger annoying memory leak warnings and other potential issues\n          // outlined in the issue linked below.\n          //\n          // @see https://github.com/joyent/node/issues/4971\n          //\n          Primus.requires('util').inherits(Primus, Stream);\n        } catch (e) {\n          Primus.Stream = EventEmitter;\n          Primus.prototype = new EventEmitter();\n        }\n\n        /**\n         * Primus readyStates, used internally to set the correct ready state.\n         *\n         * @type {Number}\n         * @private\n         */\n        Primus.OPENING = 1;   // We're opening the connection.\n        Primus.CLOSED = 2;   // No active connection.\n        Primus.OPEN = 3;   // The connection is open.\n\n        /**\n         * Are we working with a potentially broken WebSockets implementation? This\n         * boolean can be used by transformers to remove `WebSockets` from their\n         * supported transports.\n         *\n         * @type {Boolean}\n         * @private\n         */\n        Primus.prototype.AVOID_WEBSOCKETS = false;\n\n        /**\n         * Some browsers support registering emitting `online` and `offline` events when\n         * the connection has been dropped on the client. We're going to detect it in\n         * a simple `try {} catch (e) {}` statement so we don't have to do complicated\n         * feature detection.\n         *\n         * @type {Boolean}\n         * @private\n         */\n        Primus.prototype.NETWORK_EVENTS = false;\n        Primus.prototype.online = true;\n\n        try {\n          if (\n            Primus.prototype.NETWORK_EVENTS = 'onLine' in navigator\n              && (window.addEventListener || document.body.attachEvent)\n          ) {\n            if (!navigator.onLine) {\n              Primus.prototype.online = false;\n          }\n        }\n        } catch (e) {\n        }\n\n        /**\n         * The Ark contains all our plugins definitions. It's namespaced by\n         * name => plugin.\n         *\n         * @type {Object}\n         * @private\n         */\n        Primus.prototype.ark = {};\n\n        /**\n         * Simple emit wrapper that returns a function that emits an event once it's\n         * called. This makes it easier for transports to emit specific events.\n         *\n         * @returns {Function} A function that will emit the event when called.\n         * @api public\n         */\n        Primus.prototype.emits = _dereq_('emits');\n\n        /**\n         * Return the given plugin.\n         *\n         * @param {String} name The name of the plugin.\n         * @returns {Object|undefined} The plugin or undefined.\n         * @api public\n         */\n        Primus.prototype.plugin = function plugin(name) {\n          context(this, 'plugin');\n\n          if (name) return this.ark[name];\n\n          var plugins = {};\n\n          for (name in this.ark) {\n            plugins[name] = this.ark[name];\n          }\n\n          return plugins;\n        };\n\n        /**\n         * Checks if the given event is an emitted event by Primus.\n         *\n         * @param {String} evt The event name.\n         * @returns {Boolean} Indication of the event is reserved for internal use.\n         * @api public\n         */\n        Primus.prototype.reserved = function reserved(evt) {\n          return (/^(incoming|outgoing)::/).test(evt)\n            || evt in this.reserved.events;\n        };\n\n        /**\n         * The actual events that are used by the client.\n         *\n         * @type {Object}\n         * @public\n         */\n        Primus.prototype.reserved.events = {\n          'reconnect scheduled': 1,\n          'reconnect timeout': 1,\n          'readyStateChange': 1,\n          'reconnect failed': 1,\n          'reconnected': 1,\n          'reconnect': 1,\n          'offline': 1,\n          'timeout': 1,\n          'online': 1,\n          'error': 1,\n          'close': 1,\n          'open': 1,\n          'data': 1,\n          'end': 1\n        };\n\n        /**\n         * Initialise the Primus and setup all parsers and internal listeners.\n         *\n         * @param {Object} options The original options object.\n         * @returns {Primus}\n         * @api private\n         */\n        Primus.prototype.initialise = function initialise(options) {\n          var primus = this\n            , start;\n\n          primus.recovery\n            .on('reconnected', primus.emits('reconnected'))\n            .on('reconnect failed', primus.emits('reconnect failed', function failed(next) {\n              primus.emit('end');\n              next();\n            }))\n            .on('reconnect timeout', primus.emits('reconnect timeout'))\n            .on('reconnect scheduled', primus.emits('reconnect scheduled'))\n            .on('reconnect', primus.emits('reconnect', function reconnect(next) {\n              primus.emit('outgoing::reconnect');\n              next();\n            }));\n\n          primus.on('outgoing::open', function opening() {\n            var readyState = primus.readyState;\n\n            primus.readyState = Primus.OPENING;\n            if (readyState !== primus.readyState) {\n              primus.emit('readyStateChange', 'opening');\n            }\n\n            start = +new Date();\n          });\n\n          primus.on('incoming::open', function opened() {\n            var readyState = primus.readyState;\n\n            if (primus.recovery.reconnecting()) {\n              primus.recovery.reconnected();\n            }\n\n            //\n            // The connection has been opened so we should set our state to\n            // (writ|read)able so our stream compatibility works as intended.\n            //\n            primus.writable = true;\n            primus.readable = true;\n\n            //\n            // Make sure we are flagged as `online` as we've successfully opened the\n            // connection.\n            //\n            if (!primus.online) {\n              primus.online = true;\n              primus.emit('online');\n            }\n\n            primus.readyState = Primus.OPEN;\n            if (readyState !== primus.readyState) {\n              primus.emit('readyStateChange', 'open');\n            }\n\n            primus.latency = +new Date() - start;\n            primus.timers.clear('ping', 'pong');\n            primus.heartbeat();\n\n            if (primus.buffer.length) {\n              var data = primus.buffer.slice()\n                , length = data.length\n                , i = 0;\n\n              primus.buffer.length = 0;\n\n              for (; i < length; i++) {\n                primus._write(data[i]);\n            }\n            }\n\n            primus.emit('open');\n          });\n\n          primus.on('incoming::pong', function pong(time) {\n            primus.online = true;\n            primus.timers.clear('pong');\n            primus.heartbeat();\n\n            primus.latency = (+new Date()) - time;\n          });\n\n          primus.on('incoming::error', function error(e) {\n            var connect = primus.timers.active('connect')\n              , err = e;\n\n            //\n            // When the error is not an Error instance we try to normalize it.\n            //\n            if ('string' === typeof e) {\n              err = new Error(e);\n            } else if (!(e instanceof Error) && 'object' === typeof e) {\n            //\n              // BrowserChannel and SockJS returns an object which contains some\n              // details of the error. In order to have a proper error we \"copy\" the\n              // details in an Error instance.\n            //\n              err = new Error(e.message || e.reason);\n              for (var key in e) {\n                if (Object.prototype.hasOwnProperty.call(e, key))\n                  err[key] = e[key];\n            }\n            }\n            //\n            // We're still doing a reconnect attempt, it could be that we failed to\n            // connect because the server was down. Failing connect attempts should\n            // always emit an `error` event instead of a `open` event.\n            //\n            //\n            if (primus.recovery.reconnecting()) return primus.recovery.reconnected(err);\n            if (primus.listeners('error').length) primus.emit('error', err);\n\n            //\n            // We received an error while connecting, this most likely the result of an\n            // unauthorized access to the server.\n            //\n            if (connect) {\n              if (~primus.options.strategy.indexOf('timeout')) {\n                primus.recovery.reconnect();\n              } else {\n                primus.end();\n            }\n            }\n          });\n\n          primus.on('incoming::data', function message(raw) {\n            primus.decoder(raw, function decoding(err, data) {\n            //\n              // Do a \"safe\" emit('error') when we fail to parse a message. We don't\n              // want to throw here as listening to errors should be optional.\n            //\n              if (err) return primus.listeners('error').length && primus.emit('error', err);\n\n            //\n              // Handle all \"primus::\" prefixed protocol messages.\n            //\n              if (primus.protocol(data)) return;\n              primus.transforms(primus, primus, 'incoming', data, raw);\n          });\n          });\n\n          primus.on('incoming::end', function end() {\n            var readyState = primus.readyState;\n\n          //\n            // This `end` started with the receiving of a primus::server::close packet\n            // which indicated that the user/developer on the server closed the\n            // connection and it was not a result of a network disruption. So we should\n            // kill the connection without doing a reconnect.\n          //\n            if (primus.disconnect) {\n              primus.disconnect = false;\n\n              return primus.end();\n          }\n\n          //\n            // Always set the readyState to closed, and if we're still connecting, close\n            // the connection so we're sure that everything after this if statement block\n            // is only executed because our readyState is set to `open`.\n          //\n            primus.readyState = Primus.CLOSED;\n            if (readyState !== primus.readyState) {\n              primus.emit('readyStateChange', 'end');\n          }\n\n            if (primus.timers.active('connect')) primus.end();\n            if (readyState !== Primus.OPEN) {\n              return primus.recovery.reconnecting()\n                ? primus.recovery.reconnect()\n                : false;\n          }\n\n            this.writable = false;\n            this.readable = false;\n\n            //\n            // Clear all timers in case we're not going to reconnect.\n            //\n            this.timers.clear();\n\n          //\n            // Fire the `close` event as an indication of connection disruption.\n            // This is also fired by `primus#end` so it is emitted in all cases.\n          //\n            primus.emit('close');\n\n          //\n            // The disconnect was unintentional, probably because the server has\n            // shutdown, so if the reconnection is enabled start a reconnect procedure.\n          //\n            if (~primus.options.strategy.indexOf('disconnect')) {\n              return primus.recovery.reconnect();\n            }\n\n            primus.emit('outgoing::end');\n            primus.emit('end');\n          });\n\n          //\n          // Setup the real-time client.\n          //\n          primus.client();\n\n          //\n          // Process the potential plugins.\n          //\n          for (var plugin in primus.ark) {\n            primus.ark[plugin].call(primus, primus, options);\n          }\n\n          //\n          // NOTE: The following code is only required if we're supporting network\n          // events as it requires access to browser globals.\n          //\n          if (!primus.NETWORK_EVENTS) return primus;\n\n        /**\n         * Handler for offline notifications.\n         *\n         * @api private\n         */\n        primus.offlineHandler = function offline() {\n          if (!primus.online) return; // Already or still offline, bailout.\n\n          primus.online = false;\n          primus.emit('offline');\n          primus.end();\n\n          //\n          // It is certainly possible that we're in a reconnection loop and that the\n          // user goes offline. In this case we want to kill the existing attempt so\n          // when the user goes online, it will attempt to reconnect freshly again.\n          //\n          primus.recovery.reset();\n        };\n\n        /**\n         * Handler for online notifications.\n         *\n         * @api private\n         */\n        primus.onlineHandler = function online() {\n          if (primus.online) return; // Already or still online, bailout.\n\n          primus.online = true;\n          primus.emit('online');\n\n          if (~primus.options.strategy.indexOf('online')) {\n            primus.recovery.reconnect();\n          }\n        };\n\n          if (window.addEventListener) {\n            window.addEventListener('offline', primus.offlineHandler, false);\n            window.addEventListener('online', primus.onlineHandler, false);\n          } else if (document.body.attachEvent) {\n            document.body.attachEvent('onoffline', primus.offlineHandler);\n            document.body.attachEvent('ononline', primus.onlineHandler);\n          }\n\n          return primus;\n        };\n\n        /**\n         * Really dead simple protocol parser. We simply assume that every message that\n         * is prefixed with `primus::` could be used as some sort of protocol definition\n         * for Primus.\n         *\n         * @param {String} msg The data.\n         * @returns {Boolean} Is a protocol message.\n         * @api private\n         */\n        Primus.prototype.protocol = function protocol(msg) {\n          if (\n            'string' !== typeof msg\n            || msg.indexOf('primus::') !== 0\n          ) return false;\n\n          var last = msg.indexOf(':', 8)\n            , value = msg.slice(last + 2);\n\n          switch (msg.slice(8, last)) {\n            case 'pong':\n              this.emit('incoming::pong', +value);\n              break;\n\n            case 'server':\n            //\n              // The server is closing the connection, forcefully disconnect so we don't\n              // reconnect again.\n            //\n              if ('close' === value) {\n                this.disconnect = true;\n            }\n              break;\n\n            case 'id':\n              this.emit('incoming::id', value);\n              break;\n\n            //\n            // Unknown protocol, somebody is probably sending `primus::` prefixed\n            // messages.\n            //\n            default:\n              return false;\n          }\n\n          return true;\n        };\n\n        /**\n         * Execute the set of message transformers from Primus on the incoming or\n         * outgoing message.\n         * This function and it's content should be in sync with Spark#transforms in\n         * spark.js.\n         *\n         * @param {Primus} primus Reference to the Primus instance with message transformers.\n         * @param {Spark|Primus} connection Connection that receives or sends data.\n         * @param {String} type The type of message, 'incoming' or 'outgoing'.\n         * @param {Mixed} data The data to send or that has been received.\n         * @param {String} raw The raw encoded data.\n         * @returns {Primus}\n         * @api public\n         */\n        Primus.prototype.transforms = function transforms(primus, connection, type, data, raw) {\n          var packet = {data: data}\n            , fns = primus.transformers[type];\n\n          //\n          // Iterate in series over the message transformers so we can allow optional\n          // asynchronous execution of message transformers which could for example\n          // retrieve additional data from the server, do extra decoding or even\n          // message validation.\n          //\n          (function transform(index, done) {\n            var transformer = fns[index++];\n\n            if (!transformer) return done();\n\n            if (1 === transformer.length) {\n              if (false === transformer.call(connection, packet)) {\n                //\n                // When false is returned by an incoming transformer it means that's\n                // being handled by the transformer and we should not emit the `data`\n                // event.\n                //\n                return;\n              }\n\n              return transform(index, done);\n          }\n\n            transformer.call(connection, packet, function finished(err, arg) {\n              if (err) return connection.emit('error', err);\n              if (false === arg) return;\n\n              transform(index, done);\n            });\n          }(0, function done() {\n            //\n            // We always emit 2 arguments for the data event, the first argument is the\n            // parsed data and the second argument is the raw string that we received.\n            // This allows you, for example, to do some validation on the parsed data\n            // and then save the raw string in your database without the stringify\n            // overhead.\n            //\n            if ('incoming' === type) return connection.emit('data', packet.data, raw);\n\n            connection._write(packet.data);\n          }));\n\n          return this;\n        };\n\n        /**\n         * Retrieve the current id from the server.\n         *\n         * @param {Function} fn Callback function.\n         * @returns {Primus}\n         * @api public\n         */\n        Primus.prototype.id = function id(fn) {\n          if (this.socket && this.socket.id) return fn(this.socket.id);\n\n          this._write('primus::id::');\n          return this.once('incoming::id', fn);\n        };\n\n        /**\n         * Establish a connection with the server. When this function is called we\n         * assume that we don't have any open connections. If you do call it when you\n         * have a connection open, it could cause duplicate connections.\n         *\n         * @returns {Primus}\n         * @api public\n         */\n        Primus.prototype.open = function open() {\n          context(this, 'open');\n\n          //\n          // Only start a `connection timeout` procedure if we're not reconnecting as\n          // that shouldn't count as an initial connection. This should be started\n          // before the connection is opened to capture failing connections and kill the\n          // timeout.\n          //\n          if (!this.recovery.reconnecting() && this.options.timeout) this.timeout();\n\n          this.emit('outgoing::open');\n          return this;\n        };\n\n        /**\n         * Send a new message.\n         *\n         * @param {Mixed} data The data that needs to be written.\n         * @returns {Boolean} Always returns true as we don't support back pressure.\n         * @api public\n         */\n        Primus.prototype.write = function write(data) {\n          context(this, 'write');\n          this.transforms(this, this, 'outgoing', data);\n\n          return true;\n        };\n\n        /**\n         * The actual message writer.\n         *\n         * @param {Mixed} data The message that needs to be written.\n         * @returns {Boolean} Successful write to the underlaying transport.\n         * @api private\n         */\n        Primus.prototype._write = function write(data) {\n          var primus = this;\n\n          //\n          // The connection is closed, normally this would already be done in the\n          // `spark.write` method, but as `_write` is used internally, we should also\n          // add the same check here to prevent potential crashes by writing to a dead\n          // socket.\n          //\n          if (Primus.OPEN !== primus.readyState) {\n          //\n            // If the buffer is at capacity, remove the first item.\n          //\n            if (this.buffer.length === this.options.queueSize) {\n              this.buffer.splice(0, 1);\n            }\n\n            this.buffer.push(data);\n            return false;\n          }\n\n          primus.encoder(data, function encoded(err, packet) {\n          //\n            // Do a \"safe\" emit('error') when we fail to parse a message. We don't\n            // want to throw here as listening to errors should be optional.\n          //\n            if (err) return primus.listeners('error').length && primus.emit('error', err);\n\n          //\n            // Hack 1: \\u2028 and \\u2029 are allowed inside a JSON string, but JavaScript\n            // defines them as newline separators. Unescaped control characters are not\n            // allowed inside JSON strings, so this causes an error at parse time. We\n            // work around this issue by escaping these characters. This can cause\n            // errors with JSONP requests or if the string is just evaluated.\n          //\n            if ('string' === typeof packet) {\n              if (~packet.indexOf('\\u2028')) packet = packet.replace(u2028, '\\\\u2028');\n              if (~packet.indexOf('\\u2029')) packet = packet.replace(u2029, '\\\\u2029');\n            }\n\n            primus.emit('outgoing::data', packet);\n          });\n\n          return true;\n        };\n\n        /**\n         * Send a new heartbeat over the connection to ensure that we're still\n         * connected and our internet connection didn't drop. We cannot use server side\n         * heartbeats for this unfortunately.\n         *\n         * @returns {Primus}\n         * @api private\n         */\n        Primus.prototype.heartbeat = function heartbeat() {\n          var primus = this;\n\n          if (!primus.options.ping) return primus;\n\n        /**\n         * Exterminate the connection as we've timed out.\n         *\n         * @api private\n         */\n        function pong() {\n          primus.timers.clear('pong');\n\n          //\n          // The network events already captured the offline event.\n          //\n          if (!primus.online) return;\n\n          primus.online = false;\n          primus.emit('offline');\n          primus.emit('incoming::end');\n        }\n\n        /**\n         * We should send a ping message to the server.\n         *\n         * @api private\n         */\n        function ping() {\n          var value = +new Date();\n\n          primus.timers.clear('ping');\n          primus._write('primus::ping::' + value);\n          primus.emit('outgoing::ping', value);\n          primus.timers.setTimeout('pong', pong, primus.options.pong);\n        }\n\n          primus.timers.setTimeout('ping', ping, primus.options.ping);\n          return this;\n        };\n\n        /**\n         * Start a connection timeout.\n         *\n         * @returns {Primus}\n         * @api private\n         */\n        Primus.prototype.timeout = function timeout() {\n          var primus = this;\n\n        /**\n         * Remove all references to the timeout listener as we've received an event\n         * that can be used to determine state.\n         *\n         * @api private\n         */\n        function remove() {\n          primus.removeListener('error', remove)\n            .removeListener('open', remove)\n            .removeListener('end', remove)\n            .timers.clear('connect');\n        }\n\n          primus.timers.setTimeout('connect', function expired() {\n            remove(); // Clean up old references.\n\n            if (primus.readyState === Primus.OPEN || primus.recovery.reconnecting()) {\n              return;\n            }\n\n            primus.emit('timeout');\n\n          //\n            // We failed to connect to the server.\n          //\n            if (~primus.options.strategy.indexOf('timeout')) {\n              primus.recovery.reconnect();\n            } else {\n              primus.end();\n          }\n          }, primus.options.timeout);\n\n          return primus.on('error', remove)\n            .on('open', remove)\n            .on('end', remove);\n        };\n\n        /**\n         * Close the connection completely.\n         *\n         * @param {Mixed} data last packet of data.\n         * @returns {Primus}\n         * @api public\n         */\n        Primus.prototype.end = function end(data) {\n          context(this, 'end');\n\n        if (\n          this.readyState === Primus.CLOSED\n          && !this.timers.active('connect')\n          && !this.timers.active('open')\n        ) {\n          //\n          // If we are reconnecting stop the reconnection procedure.\n          //\n          if (this.recovery.reconnecting()) {\n            this.recovery.reset();\n            this.emit('end');\n          }\n\n          return this;\n        }\n\n          if (data !== undefined) this.write(data);\n\n          this.writable = false;\n          this.readable = false;\n\n          var readyState = this.readyState;\n          this.readyState = Primus.CLOSED;\n\n          if (readyState !== this.readyState) {\n            this.emit('readyStateChange', 'end');\n          }\n\n          this.timers.clear();\n          this.emit('outgoing::end');\n          this.emit('close');\n          this.emit('end');\n\n          return this;\n        };\n\n        /**\n         * Completely demolish the Primus instance and forcefully nuke all references.\n         *\n         * @returns {Boolean}\n         * @api public\n         */\n        Primus.prototype.destroy = destroy('url timers options recovery socket transport transformers', {\n          before: 'end',\n          after: ['removeAllListeners', function detach() {\n            if (!this.NETWORK_EVENTS) return;\n\n            if (window.addEventListener) {\n              window.removeEventListener('offline', this.offlineHandler);\n              window.removeEventListener('online', this.onlineHandler);\n            } else if (document.body.attachEvent) {\n              document.body.detachEvent('onoffline', this.offlineHandler);\n              document.body.detachEvent('ononline', this.onlineHandler);\n            }\n          }]\n        });\n\n        /**\n         * Create a shallow clone of a given object.\n         *\n         * @param {Object} obj The object that needs to be cloned.\n         * @returns {Object} Copy.\n         * @api private\n         */\n        Primus.prototype.clone = function clone(obj) {\n          return this.merge({}, obj);\n        };\n\n        /**\n         * Merge different objects in to one target object.\n         *\n         * @param {Object} target The object where everything should be merged in.\n         * @returns {Object} Original target with all merged objects.\n         * @api private\n         */\n        Primus.prototype.merge = function merge(target) {\n          for (var i = 1, key, obj; i < arguments.length; i++) {\n            obj = arguments[i];\n\n            for (key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key))\n                target[key] = obj[key];\n            }\n          }\n\n          return target;\n        };\n\n        /**\n         * Parse the connection string.\n         *\n         * @type {Function}\n         * @param {String} url Connection URL.\n         * @returns {Object} Parsed connection.\n         * @api private\n         */\n        Primus.prototype.parse = _dereq_('url-parse');\n\n        /**\n         * Parse a query string.\n         *\n         * @param {String} query The query string that needs to be parsed.\n         * @returns {Object} Parsed query string.\n         * @api private\n         */\n        Primus.prototype.querystring = qs.parse;\n        /**\n         * Transform a query string object back into string equiv.\n         *\n         * @param {Object} obj The query string object.\n         * @returns {String}\n         * @api private\n         */\n        Primus.prototype.querystringify = qs.stringify;\n\n        /**\n         * Generates a connection URI.\n         *\n         * @param {String} protocol The protocol that should used to crate the URI.\n         * @returns {String|options} The URL.\n         * @api private\n         */\n        Primus.prototype.uri = function uri(options) {\n          var url = this.url\n            , server = []\n            , qsa = false;\n\n          //\n          // Query strings are only allowed when we've received clearance for it.\n          //\n          if (options.query) qsa = true;\n\n          options = options || {};\n          options.protocol = 'protocol' in options\n            ? options.protocol\n            : 'http:';\n          options.query = url.query && qsa\n            ? url.query.slice(1)\n            : false;\n          options.secure = 'secure' in options\n            ? options.secure\n            : url.protocol === 'https:' || url.protocol === 'wss:';\n          options.auth = 'auth' in options\n            ? options.auth\n            : url.auth;\n          options.pathname = 'pathname' in options\n            ? options.pathname\n            : this.pathname;\n          options.port = 'port' in options\n            ? +options.port\n            : +url.port || (options.secure ? 443 : 80);\n\n          //\n          // Allow transformation of the options before we construct a full URL from it.\n          //\n          this.emit('outgoing::url', options);\n\n          //\n          // We need to make sure that we create a unique connection URL every time to\n          // prevent back forward cache from becoming an issue. We're doing this by\n          // forcing an cache busting query string in to the URL.\n          //\n          var querystring = this.querystring(options.query || '');\n          querystring._primuscb = yeast();\n          options.query = this.querystringify(querystring);\n\n          //\n          // Automatically suffix the protocol so we can supply `ws:` and `http:` and\n          // it gets transformed correctly.\n          //\n          server.push(options.secure ? options.protocol.replace(':', 's:') : options.protocol, '');\n\n          server.push(options.auth ? options.auth + '@' + url.host : url.host);\n\n          //\n          // Pathnames are optional as some Transformers would just use the pathname\n          // directly.\n          //\n          if (options.pathname) server.push(options.pathname.slice(1));\n\n          //\n          // Optionally add a search query.\n          //\n          if (qsa) server[server.length - 1] += '?' + options.query;\n          else delete options.query;\n\n          if (options.object) return options;\n          return server.join('/');\n        };\n\n        /**\n         * Register a new message transformer. This allows you to easily manipulate incoming\n         * and outgoing data which is particularity handy for plugins that want to send\n         * meta data together with the messages.\n         *\n         * @param {String} type Incoming or outgoing\n         * @param {Function} fn A new message transformer.\n         * @returns {Primus}\n         * @api public\n         */\n        Primus.prototype.transform = function transform(type, fn) {\n          context(this, 'transform');\n\n          if (!(type in this.transformers)) {\n            return this.critical(new Error('Invalid transformer type'));\n          }\n\n          this.transformers[type].push(fn);\n          return this;\n        };\n\n        /**\n         * A critical error has occurred, if we have an `error` listener, emit it there.\n         * If not, throw it, so we get a stack trace + proper error message.\n         *\n         * @param {Error} err The critical error.\n         * @returns {Primus}\n         * @api private\n         */\n        Primus.prototype.critical = function critical(err) {\n          if (this.listeners('error').length) {\n            this.emit('error', err);\n            return this;\n          }\n\n          throw err;\n        };\n\n        /**\n         * Syntax sugar, adopt a Socket.IO like API.\n         *\n         * @param {String} url The URL we want to connect to.\n         * @param {Object} options Connection options.\n         * @returns {Primus}\n         * @api public\n         */\n        Primus.connect = function connect(url, options) {\n          return new Primus(url, options);\n        };\n\n//\n// Expose the EventEmitter so it can be re-used by wrapping libraries we're also\n// exposing the Stream interface.\n//\n        Primus.EventEmitter = EventEmitter;\n\n//\n// These libraries are automatically inserted at the server-side using the\n// Primus#library method.\n//\n        Primus.prototype.client = function client() {\n          var primus = this\n            , socket;\n\n          //\n          // Select an available WebSocket factory.\n          //\n          var Factory = (function factory() {\n            if ('undefined' !== typeof WebSocket) return WebSocket;\n            if ('undefined' !== typeof MozWebSocket) return MozWebSocket;\n\n            try {\n              return Primus.requires('ws');\n            }\n            catch (e) {\n            }\n\n            return undefined;\n          })();\n\n          if (!Factory) return primus.critical(new Error(\n            'Missing required `ws` module. Please run `npm install --save ws`'\n          ));\n\n          //\n          // Connect to the given URL.\n          //\n          primus.on('outgoing::open', function opening() {\n            primus.emit('outgoing::end');\n\n            //\n            // FireFox will throw an error when we try to establish a connection from\n            // a secure page to an unsecured WebSocket connection. This is inconsistent\n            // behaviour between different browsers. This should ideally be solved in\n            // Primus when we connect.\n            //\n            try {\n              var prot = primus.url.protocol === 'ws+unix:' ? 'ws+unix:' : 'ws:'\n                , qsa = prot === 'ws:';\n\n              //\n              // Only allow primus.transport object in Node.js, it will throw in\n              // browsers with a TypeError if we supply to much arguments.\n              //\n              if (Factory.length === 3) {\n                primus.socket = socket = new Factory(\n                  primus.uri({protocol: prot, query: qsa}),   // URL\n                  [],                                           // Sub protocols\n                  primus.transport                              // options.\n                );\n              } else {\n                primus.socket = socket = new Factory(primus.uri({\n                  protocol: prot,\n                  query: qsa\n                }));\n\n                socket.binaryType = 'arraybuffer';\n            }\n            } catch (e) {\n              return primus.emit('error', e);\n            }\n\n            //\n            // Setup the Event handlers.\n            //\n            socket.onopen = primus.emits('incoming::open');\n            socket.onerror = primus.emits('incoming::error');\n            socket.onclose = primus.emits('incoming::end');\n            socket.onmessage = primus.emits('incoming::data', function parse(next, evt) {\n              next(undefined, evt.data);\n            });\n          });\n\n          //\n          // We need to write a new message to the socket.\n          //\n          primus.on('outgoing::data', function write(message) {\n            if (!socket || socket.readyState !== Factory.OPEN) return;\n\n            try {\n              socket.send(message);\n            }\n            catch (e) {\n              primus.emit('incoming::error', e);\n            }\n          });\n\n          //\n          // Attempt to reconnect the socket.\n          //\n          primus.on('outgoing::reconnect', function reconnect() {\n            primus.emit('outgoing::open');\n          });\n\n          //\n          // We need to close the socket.\n          //\n          primus.on('outgoing::end', function close() {\n            if (!socket) return;\n\n            socket.onerror = socket.onopen = socket.onclose = socket.onmessage = function () {\n            };\n            socket.close();\n            socket = null;\n          });\n        };\n        Primus.prototype.authorization = true;\n        Primus.prototype.pathname = \"/primus\";\n        Primus.prototype.encoder = function encoder(data, fn) {\n          var err;\n\n          try {\n            data = JSON.stringify(data);\n          }\n          catch (e) {\n            err = e;\n          }\n\n          fn(err, data);\n        };\n        Primus.prototype.decoder = function decoder(data, fn) {\n          var err;\n\n          if ('string' !== typeof data) return fn(err, data);\n\n          try {\n            data = JSON.parse(data);\n          }\n          catch (e) {\n            err = e;\n          }\n\n          fn(err, data);\n        };\n        Primus.prototype.version = \"5.2.2\";\n\n        if (\n          'undefined' !== typeof document\n          && 'undefined' !== typeof navigator\n        ) {\n          //\n          // Hack 2: If you press ESC in FireFox it will close all active connections.\n          // Normally this makes sense, when your page is still loading. But versions\n          // before FireFox 22 will close all connections including WebSocket connections\n          // after page load. One way to prevent this is to do a `preventDefault()` and\n          // cancel the operation before it bubbles up to the browsers default handler.\n          // It needs to be added as `keydown` event, if it's added keyup it will not be\n          // able to prevent the connection from being closed.\n          //\n          if (document.addEventListener) {\n            document.addEventListener('keydown', function keydown(e) {\n              if (e.keyCode !== 27 || !e.preventDefault) return;\n\n              e.preventDefault();\n            }, false);\n          }\n\n          //\n          // Hack 3: This is a Mac/Apple bug only, when you're behind a reverse proxy or\n          // have you network settings set to `automatic proxy discovery` the safari\n          // browser will crash when the WebSocket constructor is initialised. There is\n          // no way to detect the usage of these proxies available in JavaScript so we\n          // need to do some nasty browser sniffing. This only affects Safari versions\n          // lower then 5.1.4\n          //\n          var ua = (navigator.userAgent || '').toLowerCase()\n            , parsed = ua.match(/.+(?:rv|it|ra|ie)[\\/: ](\\d+)\\.(\\d+)(?:\\.(\\d+))?/) || []\n            , version = +[parsed[1], parsed[2]].join('.');\n\n          if (\n            !~ua.indexOf('chrome')\n            && ~ua.indexOf('safari')\n            && version < 534.54\n          ) {\n            Primus.prototype.AVOID_WEBSOCKETS = true;\n          }\n        }\n\n//\n// Expose the library.\n//\n        module.exports = Primus;\n\n      }, {\n        \"demolish\": 1,\n        \"emits\": 2,\n        \"eventemitter3\": 3,\n        \"querystringify\": 6,\n        \"recovery\": 7,\n        \"tick-tock\": 10,\n        \"url-parse\": 11,\n        \"yeast\": 13\n      }]\n    }, {}, [14])(14);\n    Primus.prototype.ark[\"emitter\"] = function () {\n    };\n    return Primus;\n  },\n  [\n    function (Primus) {\n      ;\n      (function (Primus, undefined) {\n        function spark(Spark, Emitter) {\n          'use strict';\n\n          /**\n           * `Primus#initialise` reference.\n           */\n\n          var initialise = Spark.prototype.initialise;\n\n          /**\n           * Initialise the Primus and setup all\n           * parsers and internal listeners.\n           *\n           * @api private\n           */\n\n          Spark.prototype.initialise = function init() {\n            if (!this.emitter) this.emitter = new Emitter(this);\n            if (!this.__initialise) initialise.apply(this, arguments);\n          };\n\n          // Extend the Spark to add the send method. If `Spark.readable`\n          // is not supported then we set the method on the prototype instead.\n          if (!Spark.readable) Spark.prototype.send = send;\n          else if (!Spark.prototype.send) Spark.readable('send', send);\n\n          /**\n           * Emits to this Spark.\n           *\n           * @param {String} ev The event\n           * @param {Mixed} [data] The data to broadcast\n           * @param {Function} [fn] The callback function\n           * @return {Primus|Spark} this\n           * @api public\n           */\n\n          function send(ev, data, fn) {\n            /* jshint validthis: true */\n            // ignore newListener event to avoid this error in node 0.8\n            // https://github.com/cayasso/primus-emitter/issues/3\n            if (/^(newListener|removeListener)/.test(ev)) return this;\n            this.emitter.send.apply(this.emitter, arguments);\n            return this;\n          }\n        }\n        function emitter() {\n          'use strict';\n\n          var toString = Object.prototype.toString\n            , slice = Array.prototype.slice;\n\n          /**\n           * Check if the given `value` is an `Array`.\n           *\n           * @param {*} value The value to check\n           * @return {Boolean}\n           */\n\n          var isArray = Array.isArray || function isArray(value) {\n              return '[object Array]' === toString.call(value);\n            };\n\n          /**\n           * Event packets.\n           */\n\n          var packets = {\n            EVENT: 0,\n            ACK: 1\n          };\n\n          /**\n           * Initialize a new `Emitter`.\n           *\n           * @param {Primus|Spark} conn\n           * @return {Emitter} `Emitter` instance\n           * @api public\n           */\n\n          function Emitter(conn) {\n            if (!(this instanceof Emitter)) return new Emitter(conn);\n            this.ids = 1;\n            this.acks = {};\n            this.conn = conn;\n            if (this.conn) this.bind();\n          }\n\n          /**\n           * Bind `Emitter` events.\n           *\n           * @return {Emitter} self\n           * @api private\n           */\n\n          Emitter.prototype.bind = function bind() {\n            var em = this;\n            this.conn.on('data', function ondata(packet) {\n              em.ondata.call(em, packet);\n            });\n            return this;\n          };\n\n          /**\n           * Called with incoming transport data.\n           *\n           * @param {Object} packet\n           * @return {Emitter} self\n           * @api private\n           */\n\n          Emitter.prototype.ondata = function ondata(packet) {\n            if (!isArray(packet.data) || packet.id && 'number' !== typeof packet.id) {\n              return this;\n            }\n            switch (packet.type) {\n              case packets.EVENT:\n                this.onevent(packet);\n                break;\n              case packets.ACK:\n                this.onack(packet);\n            }\n            return this;\n          };\n\n          /**\n           * Send a message to client.\n           *\n           * @return {Emitter} self\n           * @api public\n           */\n\n          Emitter.prototype.send = function send() {\n            var args = slice.call(arguments);\n            this.conn.write(this.packet(args));\n            return this;\n          };\n\n          /**\n           * Prepare packet for emitting.\n           *\n           * @param {Array} arguments\n           * @return {Object} packet\n           * @api private\n           */\n\n          Emitter.prototype.packet = function pack(args) {\n            var packet = {type: packets.EVENT, data: args};\n            // access last argument to see if it's an ACK callback\n            if ('function' === typeof args[args.length - 1]) {\n              var id = this.ids++;\n              this.acks[id] = args.pop();\n              packet.id = id;\n            }\n            return packet;\n          };\n\n          /**\n           * Called upon event packet.\n           *\n           * @param {Object} packet object\n           * @return {Emitter} self\n           * @api private\n           */\n\n          Emitter.prototype.onevent = function onevent(packet) {\n            var args = packet.data;\n            if (this.conn.reserved(args[0])) return this;\n            if (packet.id) args.push(this.ack(packet.id));\n            this.conn.emit.apply(this.conn, args);\n            return this;\n          };\n\n          /**\n           * Produces an ack callback to emit with an event.\n           *\n           * @param {Number} packet id\n           * @return {Function}\n           * @api private\n           */\n\n          Emitter.prototype.ack = function ack(id) {\n            var conn = this.conn\n              , sent = false;\n            return function () {\n              if (sent) return; // prevent double callbacks\n              sent = true;\n              conn.write({\n                id: id,\n                type: packets.ACK,\n                data: slice.call(arguments)\n              });\n            };\n          };\n\n          /**\n           * Called upon ack packet.\n           *\n           * @param {Object} packet object\n           * @return {Emitter} self\n           * @api private\n           */\n\n          Emitter.prototype.onack = function onack(packet) {\n            var ack = this.acks[packet.id];\n            if ('function' === typeof ack) {\n              ack.apply(this, packet.data);\n              delete this.acks[packet.id];\n            }\n            return this;\n          };\n\n          // Expose packets\n          Emitter.packets = packets;\n\n          return Emitter;\n        }\n        if (undefined === Primus) return;\n        Primus.$ = Primus.$ || {};\n        Primus.$.emitter = {};\n        Primus.$.emitter.spark = spark;\n        Primus.$.emitter.emitter = emitter;\n        spark(Primus, emitter());\n      })(Primus);\n    }\n  ]);\n"
  }
}, [2]);
